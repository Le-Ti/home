#!/bin/sh

# subcommander
#
# Several advanced tools (like git, subversion, cvs, zip, etc.  follow a
# pattern where the main tool is called followed by a subcommand specific to
# that system. This acts as a somewhat informal namespace for executables.
#
# This script attempts to encapsulate this pattern. It first walks up the
# directory tree looking for a .$0.context file to source. Then it looks for an
# executable named $0.d/$1 or $0.d/$1.* to execute.

basename="${0##*/}"
context_envname="`echo $basename|tr 'a-z ' 'A-Z_'`_CONTEXT"

usage () { cat <<-END
		usage: $basename COMMAND [OPTION...] [ARG]...
		
		OPTION may be one of:
		    -f Abort if the current context does not match \$$context_envname
		    -q Be quiet
		    -s Do not perform context discovery
		    -v Be more verbose
	END
}

# Setup:
#
# bin/
# 	subcommander
# 	mytool -> subcommander
#	mytool.d/
#		start.sh
#		stop.py
#		status
#
# foo/bar/
#	baz1/
#	baz2/
#		quux/
#	.mytool.context
# 
# From anywhere within foo/bar:
# 	'mytool status'
# will source foo/bar/.mytool.context, and then execute bin/mytool.d/status
# with the following variables set:
# 
# TODO: finish this
#
# TODO: Integrate with prompt and/or window title?

# Reminders:
# 	${var##*/} is like `basename $var`
#	${var%/.*} is like `dirname $var`
#   ${var%.*} removes one level of filename extension
#   ${var%%.*} removes all filename extensions **
#	** This will fail if you don't ensure there are no '.' in the path!

subcommandsdir="$0.d"
context_mismatch_action='warn'
verbose=
eval "environment_context=\$$context_envname"

while getopts sfqv f
do
	case "$f" in
		s)	skip_context_discovery=1
			;;
		f)	context_mismatch_action='abort'
			;;
		q)	context_mismatch_action='ignore'
			verbose=
			;;
		v)	verbose=1
	esac
done
shift $(($OPTIND - 1))

list_subcommands () {
	local seen
	if [ -d "$subcommandsdir" ]; then
		for f in "$0.d"/*; do
			[ -x "$f" ] || continue
			[ $seen ] || {
				echo "Available $basename commands are:"
				seen=1
			}
			printf \
				"   %-10s %s\n" \
				"`basename \"$f\"`" \
				"`sed -n '1,10s/^.\{0,4\}desc\(ription\)\?\s*[:=]\s*//Ip' \"$f\"`"
		done
		[ $seen ] || fmt <<-END
			Subcommands directory $subcommandsdir contains no executables. Place
			executable files here to enable them as sub-commands of '$basename'.
		END
	else
		fmt <<-END
			Subcommands directory $subcommandsdir does not exist. Place executable
			files there to enable them as sub-commands of '$basename'.
		END
	fi
}

# Functions which take messages as standard input
warn () {
	fmt >&2
}
ignore () {
	cat > /dev/null
}
abort () {
	warn; exit $1
}
usage_abort () {
	usage
	echo
	list_subcommands
	echo
	abort $1
}

# Were we called with any arguments at all?
[ $# -gt 0 ] || usage_abort 2 <<-END
		No COMMAND specified.
	END

subcommandbase="$1"
subcommand="$subcommandsdir/$1"
shift; subcommandargs="$@"

# Find the nearest context file in the directory hierarchy.
[ "$skip_context_discovery" ] || {
	discovered_contextfile=`acquire ".$basename.context"`
	discovered_context="${discovered_contextfile%/*}"
}

# If context is manually set, ensure it exists.
if [ "$environment_context" ]; then
	environment_contextfile="$environment_context/.$basename.context"

	[ -f "$environment_contextfile" ] || abort 3 <<-END
		The context specified by $context_envname does not exist:
		$environment_contextfile not found.
	END
fi

# If both are set, see if one differs from the other. (Possibly confused user.)
if [ "$environment_contextfile" -a "$discovered_contextfile" ]; then
	if [ ! "$environment_contextfile" -ef "$discovered_contextfile" ]; then
		$warn <<-END
			Warning: Context specified by $context_envname=$environment_context
			differs from and overrides context discovered at $discovered_context.
			Be sure that this is what you intend.
		END
	fi
fi

# Prefer environment-specified context over discovered context.
# TODO: prefer argument-specified context over both.
if [ "$environment_contextfile" ]; then
	contextfile="$environment_contextfile"
elif [ "$discovered_contextfile" ]; then
	contextfile="$discovered_contextfile"
fi

# Source context or mention that it is non-existent.
if [ "$contextfile" ]; then
	[ "$verbose" ] && echo "Sourcing context $contextfile..." | warn
	set -a
	. "$contextfile"
	set +a
else
	[ "$verbose" ] && echo Note: no context was found. | warn
fi

# Check to ensure subcommand is an executable
[ -x "$subcommand" ] || abort <<-END
	error: unknown $basename command: $subcommandbase.
END

# Launch subcommand.
export SUBCOMMANDER="$basename"
exec "$subcommand" "$subcommandargs"
