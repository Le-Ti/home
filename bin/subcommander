#!/bin/sh

# subcommander
#
# Several advanced tools (like git, subversion, cvs, zip, etc.
# follow a pattern where the main tool is called followed by a
# subcommand specific to that system. This acts as a somewhat
# informal namespace for executables.
#
# This script attempts to encapsulate this pattern. It first walks
# up the directory tree looking for a .$0.context file to source.
# Then it looks for an executable named $0.d/$1 or $0.d/$1.* to
# execute.
#
# Setup:
#
# bin/
# 	subcommander
# 	mytool -> subcommander
#	mytool.d/
#		start.sh
#		stop.py
#		status
#
# foo/bar/
#	baz1/
#	baz2/
#		quux/
#	.mytool.context
# 
# From anywhere within foo/bar:
# 	'mytool status'
# will source foo/bar/.mytool.context, and then execute bin/mytool.d/status with the following variables set:
# 
# TODO: finish this
#
# The following subcommands are always available, though they may be overridden if defined in a subtool:
#
#	exec 	execute a shell or any other executable, and store the context in the environment. (disables context file searching)
#
#	help COMMAND	gives more information about a particular subcommand.
# 	
# TODO: how to integrate with prompt and/or window title?
